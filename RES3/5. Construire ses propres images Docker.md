La construction des images s'effectue à l'aide d'un **Dockerfile**.

Ce fichier s'apparente à une recette de cuisine, des commandes permettent de construire l'image :

La syntaxe de base d'une instruction est la suivante :

```dockerfile
INSTRUCTION argument
```

L'instruction n'est pas sensible à la casse, mais elle est généralement écrite en majuscule car plus facile à distinguer des arguments ainsi.

>[!danger] Un **Dockerfile doit commencer par une instruction `FROM`**

Vous pouvez ajouter des commentaires dans les Dockerfile avec le préfixe `# `.

#### Liste des instructions 

##### `FROM` : Choisir une image de départ

| Instruction             | Description                                                        |
| ----------------------- | ------------------------------------------------------------------ |
| `FROM <image>`          | Permet d'indiquer l'image de base de l'image qu'on souhaite créer  |
| `FROM <image>:<tag>`    | Permet d'indiquer l'image de base avec un numéro de version précis |
| `FROM <image>@<digest>` | Fonctionnement similaire à `FROM <image>:<tag>`                    | 

Exemple :

```dockerfile
FROM ubuntu:lastest
```

---
##### `MAINTAINER` : Indiquer un auteur

| Instruction         | Description                                                       |
| ------------------- | ----------------------------------------------------------------- |
| `MAINTAINER <name>` | Permet d'indiquer l'auteur de l'image qui sera générée |

Exemple :

```dockerfile
MAINTAINER "exemple@exemple.com"
```

---
##### `RUN` : Lancer une commande Shell

| Instruction                                           | Description                                                                                                                    |
| ----------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| `RUN <command>`                                       | Permet de lancer une commande via le Shell de l'image (`/bin/sh -c <command>` sous Linux et `cmd /S /C <command>` sur Windows) |
| `RUN ["<executable>","<param-1>","<param-2>",...,"<param-n>"]` | Permet la même chose que `RUN <command>` mais sous l'écriture type `exec` (voir cours [[5. Appels système - Gestion des Processus]])                                                                                                                               |

Exemple :

```Dockerfile
# Installation des mises à jour de l'OS
RUN "sudo apt update && sudo apt upgrade -y"

# Lister tous les fichiers du WORKDIR de façon détaillée, incluant les fichiers cachés
# Oui, ça sert a rien ici mais c'est un exemple. C'est toujours mieux qu'installer  python.
RUN ["ls", "-l", "-A"]
```

La seconde forme (type `exec`) existe pour éviter la confusion sur la composition des arguments, éviter de devoir passer des `\"` tout le temps. Cependant elle ne permet pas d'utiliser les variables d'environnement, ex: Utiliser `$HOME` ne fonctionnera pas.

Le Shell par défaut peut être changé en utilisant la commande : 

```dockerfile
SHELL <shell-path>
```

---
##### `CMD` : La commande la plus importante : l'exécutable final

| Instruction                                                    | Description                                                                                                                            |
| -------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| `CMD ["<executable>","<param-1>","<param-2>",...,"<param-n>"]` | Permet comme `RUN` de lancer une exécutable. Cependant il s'agit de l'instruction qui doit lancer le programme principal du container. |
| `CMD <command> <param-1> <param-2> ... <param-n>`              | Permet de lancer l'exécutable principal avec une commande de format Shell.                                                                                                                                       |

>[!danger] Il ne peut y avoir qu'une seule instruction `CMD` dans une image !

Exemple :

```dockerfile
CMD ["/bin/bash"] 

# Commande utilisée dans l'image ubuntu pour considérer que le shell est le programme principal
# Si ce shell s'arrête, le container s'arrêtera avec.
```

---
##### `LABEL` : Rajouter des infos à l'image

| Instruction         | Description                                                       |
| ------------------- | ----------------------------------------------------------------- |
| `LABEL [<key=value>,<key>=<value>,...]` | Permet d'indiquer une table de métadonnées liées à l'image. Visible depuis la commande `docker inspect` |

Exemple :

```dockerfile
# Labels simples
LABEL "com.example.vendor"="ACME Incorporated"
LABEL com.example.label-with-value="foo"
LABEL version="1.0"
LABEL description="This text illustrates \
that label-values can span multiple lines."
```

```dockerfile
LABEL multi.label1="value1" multi.label2="value2" other="value3"
```

---
##### `EXPOSE` : Publier les ports sur le Docker Network

| Instruction         | Description                                                       |
| ------------------- | ----------------------------------------------------------------- |
| `EXPOSE <port>` | Expose les ports spécifiés aux Docker Networks auxquels le container est connecté. Cette directive n'expose pas les ports à l'host. |

Exemple :

```dockerfile
EXPOSE 80/tcp
EXPOSE 80/udp
```

---
##### `ENV`: Gérer l'environnement d'exécution

| Instruction         | Description                                                       |
| ------------------- | ----------------------------------------------------------------- |
| `ENV <key=value> [<key=value>,<key>=<value>,...]` | Indique la variable d'environnement de l'image. La variable est transmise aux containers utilisant cette image. |

Exemple :

```dockerfile
ENV MY_NAME="John Doe"
ENV MY_DOG=Rex\ The\ Dog
ENV MY_CAT=fluffy
```

Si une variable d'environnement n'est utile que pendant la construction de l'image, et non l'utilisation, utilisez plutôt la directive `RUN` ainsi :

```dockerfile
RUN DEBIAN_FRONTEND=noninteractive apt-get update && apt-get install -y ...
```

Ou alors la directive `ARG` :

```dockerfile
ARG DEBIAN_FRONTEND=noninteractive
RUN apt-get update && apt-get install -y ...
```

---
##### `ADD` : Copier des fichiers sur l'image, depuis l'hôte ou internet et vérifier l'intégrité

| Instruction               | Description                                                          |
| ------------------------- | -------------------------------------------------------------------- |
| `ADD <src> <dest>`        | Copie des fichiers depuis `src` depuis l'hôte, dans l'image à `dest` |
| `ADD ["<src>", <"dest">]` | Même chose que `ADD <src> <dest>` pour les chemins contenant des espaces                                                                     |

L'instruction copie des fichiers, des dossiers, ou encore des fichiers distants (download) et les ajoute au système de fichiers de l'image dans `<dest>`. 

La source peut contenir des jockers tels que `*`, `**` et `?` pour faire de la correspondance de fichiers, ex : `/srv/data/**/*`, la destination est soit un chemin absolu, soit un chemin relatif à `WORKDIR`. Si le dossier de destination n'existe pas, il est créé avec tous ses dossiers parents.

La directive `ADD` supporte plusieurs options :

| Option                   | Description                                                                              |
| ------------------------ | ---------------------------------------------------------------------------------------- |
| `--chown=<user>:<group>` | Permet d'indiquer qui est propriétaire des fichiers a copier                             |
| `--chmod=<perms>`        | Permet d'indiquer les droits sur le fichier en octal. Exemple : `600` pour `rw-,---,---` |
| `--checksum=<checksum>`  | Permet de vérifier l'intégrité du fichier via un checksum                                                                                         |

Exemple :

```dockerfile
# Ajout de tous les fichiers txt de /srv/data dans /mydir/ de l'image
ADD /srv/data/*.txt /mydir/

# Ajout de fichiers et édition des permissions 
ADD --chown=55:mygroup files* /somedir/
ADD --chown=bin files* /somedir/
ADD --chown=1 files* /somedir/
ADD --chown=10:11 files* /somedir/
ADD --chown=myuser:mygroup --chmod=655 files* /somedir/

# Ajout du fichier "linux-0.01.tar.gz" dans "/" après vérification du checksum de
# valeur 24454f830cdb571e2c4ad15481119c43b3cafd48dd869a9b2945d1036d1dc68d via SHA256
ADD --checksum=sha256:24454f830cdb571e2c4ad15481119c43b3cafd48dd869a9b2945d1036d1dc68d https://mirrors.edge.kernel.org/pub/linux/kernel/Historic/linux-0.01.tar.gz /
```

---
##### `COPY` : Copier des fichiers depuis l'hôte dans l'image

| Instruction               | Description                                                          |
| ------------------------- | -------------------------------------------------------------------- |
| `COPY <src> <dest>`        | Copie des fichiers depuis `src` depuis l'hôte, dans l'image à `dest` |
| `COPY ["<src>", <"dest">]` | Même chose que `COPY <src> <dest>` pour les chemins contenant des espaces                                                                     |

Exemple :

```dockerfile
COPY /srv/data/*.txt /mydir/
```

---
##### `USER` : Changer l'utilisateur courant

| Instruction               | Description                                                          |
| ------------------------- | -------------------------------------------------------------------- |
| `USER <user/user-id>`    | Change l'utilisateur courant à utiliser lorsque l'image sera lancée, et aussi pour l'exécution des directives `RUN`, `CMD` et `ENTRYPOINT` |
| `USER <user>:<group>`    | Change l'utilisateur courant ainsi que le groupe à utiliser lorsque l'image sera lancée, et aussi pour l'exécution des directives `RUN`, `CMD` et `ENTRYPOINT` |

Exemple :

```dockerfile
# Connexion à l'utilisateur altaks
USER altaks

# Connexion à l'utilisateur altaks de groupe ssh-allowed
USER altaks:ssh-allowed
```


---
##### `WORKDIR` : Changer le dossier courant d'exécution des directives.

| Instruction               | Description                                                          |
| ------------------------- | -------------------------------------------------------------------- |
| `WORKDIR <absolute-path>`        | Permet de changer le répertoire courant d'exécution des directives |
| `WORKDIR <relative-to-current-path>` | Permet de changer le répertoire courant via un chemin relatif au répertoire actuel|

Exemple :

```dockerfile
# Effectuer l'équivalent de `cd /var/www/html`
WORKDIR /var/www/html

# Effectuer l'équivalent de `cd ../data`
WORKDIR ../data
```

---
##### `STOPSIGNAL` : Appeler un signal système qui sera envoyé au container.

| Instruction               | Description                                                          |
| ------------------------- | -------------------------------------------------------------------- |
| `STOPSIGNAL <signal>`        | Envoie un signal qui va indiquer au container de s'arrêter. Ce signal peut être une valeur de format `SIG...` comme celles-ci : [[https://www-uxsup.csx.cam.ac.uk/courses/moved.Building/signals.pdf]] |

Exemple :

```dockerfile
STOPSIGNAL SIGQUIT
```

---
##### `HEALTHCHECK` : Vérifier le bon fonctionnement d'un container.

| Instruction                             | Description                                                 |
| --------------------------------------- | ----------------------------------------------------------- |
| `HEALTHCHECK [<options>] CMD <command>` | Permet de vérifier la santé d'un container via une commande |

Les options peuvent être : 

- `--interval=<duration>` (Valeur par défaut : 30s)
- `--timeout=<duration>` (Valeur par défaut : 30s)
- `--retries=<number>` (Valeur par défaut : 3)

>[!danger] Il ne peut y avoir qu'une seule instruction `HEALTHCHECK` dans un Dockerfile

La valeur de retour de la commande est traitée ainsi : 
- `0` : Succès, le container est en bonne santé.
- `1` : Échec, le container ne fonctionne pas correctement. 

Les premiers 4096 octets de l'entrée et la sortie standard utilisés par `command` sont stockés et peuvent être récupérés via la commande `docker inspect`.

Exemple :

```dockerfile
HEALTHCHECK --interval=5m --timeout=3s CMD curl -f http://localhost/ || exit 1
```
---

### Exemple de Dockerfiles :

Préparer un serveur php :

```dockerfile
FROM php:8.1.10-fpm-alpine3.16

# Installer XDebug
COPY ./docker/php/xdebug.ini /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini
RUN apk add bash git $PHPIZE_DEPS
RUN pecl install xdebug
RUN docker-php-ext-enable xdebug

# Modules pour utiliser MySQL
RUN docker-php-ext-install mysqli pdo_mysql

# Installer composer
RUN php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
RUN php composer-setup.php
RUN php -r "unlink('composer-setup.php');"
RUN mv composer.phar /usr/local/bin/composer

# Installer la CLI Symfony
RUN apk add --no-cache bash
RUN curl -1sLf 'https://dl.cloudsmith.io/public/symfony/stable/setup.alpine.sh' | bash
RUN apk add symfony-cli
```

Préparer un serveur web :

```dockerfile
FROM httpd:2.4.54-alpine3.16

COPY ./docker/web/httpd.conf /usr/local/apache2/conf/httpd.conf
COPY ./docker/web/vhosts.conf /usr/local/apache2/conf/extra/httpd-vhosts.conf

CMD /usr/local/apache2/bin/apachectl -D FOREGROUND
```

Préparer un serveur MariaDB : 

```dockerfile
FROM mariadb:10.9.2

VOLUME /var/lib/mysql

ADD ./docker/db/mysqld.cnf /etc/mysql/conf.d
```

--- 

### Démarrer un environnement multi-service : Docker Compose.

Docker-compose est un outil permettant depuis un fichier de démarrer un environnement multi services.

A titre d’exemple, un fichier docker-compose peut en une commande démarrer :

-  Un conteneur Apache/PHP
-  Un conteneur MySQL
-  Un conteneur PHPMyAdmin

Avec un fichier nommé `docker-compose.yml` qui sera lancé avec la commande :

```bash
docker compose up --build -d
```

Contenu du fichier `docker-compose.yml`à la racine : 
```yml
version: '3'

services:
  php:
    build:
      context: .
      dockerfile: docker/php/Dockerfile
    container_name: iut-php
    volumes:
      - "./:/var/www/html/"
  web:
    container_name: iut-web
    build:
      context: .
      dockerfile: docker/web/Dockerfile
    ports:
      - "8888:80"
      - "8887:81"
    volumes:
      - "./:/var/www/html/"
  db:
    build:
      context: .
      dockerfile: docker/db/Dockerfile
    container_name: iut-db
    ports:
      - "3307:3306" # mysql
    environment:
      MYSQL_DATABASE: iut
      MYSQL_USER: iut
      MYSQL_PASSWORD: iut
      MYSQL_ROOT_PASSWORD: iut
```

On peut remarquer que pour chaque container/service, on peut passer un nom :

```yml
services:
  <name>:
```

Que pour chaque service on peut passer un Dockerfile, un nom de container, ainsi que les volumes, les ports, les variables d'environnement et bien d'[autres](https://docs.docker.com/compose/compose-file/03-compose-file/) : 

```yml
<name>:
  build:
    context: <build-context-path>
    dockerfile: <dockerfile-path>
  container_name: <container-name>
  volumes:
    - "<host-path>:<container-path>"
    - ...
  ports:
    - "<host-port>:<container-port>"
    - ...
  environment:
    <ENVIRONMENT-VAR>: <VAR-VALUE>
    ...
```