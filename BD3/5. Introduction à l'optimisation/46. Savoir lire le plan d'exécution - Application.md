Nous allons partir de l'extrait de schéma suivant :

```sql
CREATE TABLE DEPT (
	DEPTNO         NUMBER(2)                NOT NULL,
	DNAME          VARCHAR2(14)             NULL,
	LOC            VARCHAR2(13)             NULL,
	CONSTRAINT PK_DEPT PRIMARY KEY(DEPTNO)
);

CREATE TABLE EMP (
	EMPNO          NUMBER(4)                NOT NULL,
	ENAME          VARCHAR2(10)             NULL,
	JOB            VARCHAR2(9)              NULL,
	MGR            NUMBER(4)                NULL,
	HIREDATE       DATE                     NULL,
	SAL            NUMBER(7,2)              NULL,
	COMM           NUMBER(7,2)              NULL,
	DEPTNO         NUMBER(2)                NULL
	CONSTRAINT PK_EMP PRIMARY KEY(EMPNO)
);

ALTER TABLE EMP ADD CONSTRAINT FK_DEPNO FOREIGN KEY(DEPTNO) REFERENCES DEPT(DEPTNO);

CREATE INDEX I_DEPTNO ON EMP(DEPTNO);
CREATE INDEX IN_JOB   ON EMP(JOB);
```

---
#### Application : `FULL TABLE SCAN`

Ordre SQL : 

```SQL
SELECT * FROM EMP;
```

Plan d'exécution : 

```
2 SELECT STATEMENT
1 TABLE ACCESS (FULL), EMP
```

Explication : 

1. Cette opération extrait toutes les lignes de la table `EMP` en utilisant un balayage de table complet
2. Cette étape du plan définit cette instruction comme instruction `SELECT`

---
#### Application : `SINGLE ROW BY ROWID`

Ordre SQL : 

```SQL
SELECT * FROM EMP WHERE rowid='AAAA7bAA5AAAA1UAAA';
```

Plan d'exécution : 

```
2 SELECT STATEMENT
1 TABLE ACCESS (BY USER ROWID), EMP
```

Explication : 

1. Cette opération extrait une ligne de la table `EMP` sur la base de son `ROWID`
2. Cette étape du plan définit cette instruction comme instruction `SELECT`

---
#### Application : `SINGLE ROW BY UNIQUE` ou `PRIMARY KEY`

Ordre SQL : 

```SQL
SELECT * FROM EMP WHERE empno=7900;
```

Plan d'exécution : 

```
3 SELECT STATEMENT
2 TABLE ACCESS (BY INDEX ROWID), EMP
1 INDEX (RANGE SCAN), PK_EMP
```

Explication : 

1. Cette opération extrait plusieurs `ROWID` en balayant l'index `PK_EMP` (par ordre croissant des clés "ASC PK")
2. Cette opération extrait une ligne de la table `EMP` sur la base de son `ROWID`.

---
#### Application : `CLUSTERED JOIN`

Ordre SQL : 

```SQL
SELECT * FROM EMP, DEPT WHERE EMP.deptno = DEPT.deptno;
```

Plan d'exécution : 

```
5 SELECT STATEMENT
4 NESTED LOOPS
3 TABLE ACCESS (FULL), EMP
2 TABLE ACCESS (BY INDEX ROWID), DEPT
1 INDEX (UNIQUE SCAN), PK_DEPT
```

Explication : 

1. Extrait toutes les lignes de la table `EMP` en utilisant un balayage de table complet
2. Extrait un `ROWID` unique via une consultation d'index de `PK_DEPT`
3. Extrait une ligne de la table `DEPT` sur la base de son `ROWID`
4. Compare chaque ligne, en joignant les paires de lignes répondant à la condition définie.

---
#### Application : `SINGLE ROW BY CLUSTER JOIN`

Ordre SQL : 

```SQL
SELECT * FROM EMP, DEPT WHERE EMP.deptno = DEPT.deptno AND EMP.empno=7900;
```

Plan d'exécution : 

```
6 SELECT STATEMENT
5 NESTED LOOPS
2 TABLE ACCESS (BY INDEX ROWID), EMP
1 INDEX (RANGE SCAN), PK_EMP
4 TABLE ACCESS (BY INDEX ROWID), DEPT
3 INDEX (UNIQUE SCAN), PK_DEPT
```

Explication : 

1. Extrait plusieurs `ROWID` en balayant l'index `PK_EMP` ("asc pk").
2. Extrait une ligne de la table `EMP` sur la base de son `ROWID`.
3. Extrait un `ROWID` unique via une consultation d'index de `PK_DEPT`.
4. Extrait une ligne de la table `DEPT` sur la base de son `ROWID`.
5. Compare chaque ligne de la première source de lignes enfant avec toutes les lignes de la seconde, en joignant les paires de lignes répondant à ma condition définie.

---
#### Application : `ORDER BY ON INDEXE COLUMN`

Ordre SQL : 

```SQL
SELECT * FROM EMP ORDER BY empno;
```

Plan d'exécution : 

```
3 SELECT STATEMENT
2 SORT (ORDER BY)
1 TABLE ACCESS (FULL), EMP
```

Explication : 

1. Cette opération extrait toutes les lignes de la table `EMP` en utilisant un balayage de table complet.
2. Cette opération renvoie sa source de lignes enfant triée sur la base des colonnes d'après la clause `ORDER BY`.
3. Cette étape du plan définit cette instruction comme instruction `SELECT`.

---
#### Application : `OR ON INDEXED COLUMN`

Ordre SQL : 

```SQL
SELECT * FROM EMP WHERE job='clerk' AND deptno=10;
```

Plan d'exécution : 

```
6 SELECT STATEMENT
5 CONCATENATION
2 TABLE ACCESS (BY INDEX ROWID), EMP
1 INDEX (RANGE SCAN), I_DEPTNO
4 TABLE ACCESS (BY INDEX ROWID), EMP
3 INDEX (RANGE SCAN), IN_JOB
```

Explication : 

1. Extrait plusieurs `ROWID` en balayant l'index `I_DEPTNO` ("asc pk")
2. Extrait une ligne de la table `EMP` sur la base de son `ROWID`.
3. Extrait plusieurs `ROWID` en balayant l'index `IN_JOB` ("asc pk")
4. Extrait une ligne de la table `EMP` sur la base de son `ROWID`
5. Effectue l'union non distincte de ses sources de lignes enfant.
6. Définit cette instruction comme instruction `SELECT`.

---
#### Application : `UNION ON INDEXED COLUMNS`

Ordre SQL : 

```SQL
SELECT * FROM EMP WHERE job='clerk'
UNION ALL
SELECT * FROM EMP WHERE deptno=10 AND job <> 'clerk';
```

Plan d'exécution : 

```
6 SELECT STATEMENT
5 UNION ALL
2 TABLE ACCESS (BY INDEX ROWID), EMP
1 INDEX (RANGE SCAN), IN_JOB
4 TABLE ACCESS (BY INDEX ROWID), EMP
3 INDEX (RANGE SCAN), I_DEPTNO
```

Explication : 

1. Extrait plusieurs `ROWID` en balayant l'index `IN_JOB` ("asc pk")
2. Extrait une ligne de la table `EMP` sur la base de son `ROWID`
3. Extrait plusieurs `ROWID` en balayant l'index `I_DEPTNO` ("asc pk")
4. Extrait une ligne de la table `EMP` sur la base de son `ROWID`
5. Accepte deux ensembles de lignes et renvoie l'agglomération des deux en conservant tous les doublons.

---
#### Application : `NOT EXISTS ON INDEXED COLUMNS`

Ordre SQL : 

```SQL
SELECT dname, deptno FROM dept
WHERE NOT EXISTS (
	SELECT deptno FROM EMP
	WHERE DEPT.deptno = EMP.deptno
);
```

Plan d'exécution : 

```
4 SELECT STATEMENT
3 NESTED LOOPS (ANTI)
1 TABLE ACCESS (FULL), DEPT
2 INDEX (RANGE SCAN), I_DEPTNO
```

Explication : 

1. Extrait toutes les lignes de la table `DEPT` en utilisant un balayage de table complet
2. Extrait plusieurs `ROWID` en balayant l'index `I_DEPTNO` (asc pk)
3. Compare chaque ligne de la première source de lignes enfant avec toutes les lignes de la seconde, en joignant les paires de lignes répondant à la condition définie.
4. Cette étape du plan définit cette instruction comme instruction `SELECT`.
