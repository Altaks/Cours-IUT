On peut créer un trigger `ROW` et `BEFORE` afin d'empêcher l'opération déclenchante de s'exécuter sur chaque lignée concernée lorsqu'une certaine condition n'est pas respectée.

Exemple : Un trigger `ROW` qui ne va autoriser que certains employés à gagner un salaire supérieur à 5000.

```SQL
CREATE OR REPLACE TRIGGER trigger_salaire_pct
BEFORE INSERT OR UPDATE OF salary on emp
FOR EACH ROW
BEGIN
	IF(NOT(:new.job in ('MANAGER', 'PRESIDENT')) AND :new.salary > 5000) THEN
		RAISE_APPLICATION_ERROR(-20202, 'L\'employé ne peut pas gagner autant');
	ENDIF;
END;
/
```

Si l'utilisateur essaie d'insérer un salaire supérieur à 5000, le trigger renvoie une erreur : 

```
SQLPLUS> UPDATE emp SET salary=6500 WHERE ename='MILLER';
UPDATE emp SET salary=6500 WHERE ename='MILLER';
*
ERREUR à la ligne 1 : 
ORA-20202 : L'employé ne peut pas gagner autant.
ORA-06512 : à "TRIGGER_SALAIRE_PCT", ligne 5
ORA-04088 : Erreur lors de l'exécution du déclencheur 'TRIGGER_SALAIRE_PCT'
```

---

### Les qualificatifs `:old` et `:new`

Lorsqu'on utilise un trigger `ROW`, celui-ci enregistre les valeurs de plusieurs colonnes avant et après la modification des données en utilisant les qualificatifs `OLD` et `NEW` associés au noms de colonnes respectifs.

Les qualificatifs `OLD` et `NEW` ne sont disponibles que pour les triggers de type `ROW`.
Il faut les préfixer de deux points `:` dans tout ordre PL/SQL les utilisant, cependant il ne faut pas utiliser le préfixe `:` quand les qualificatifs sont utilisés dans la condition de restriction `WHEN`.

Pour l'exemple on va utiliser une table : 

```
AUDIT_EMP_TABLE(user_name, timestamp, old_last_name, new_last_name, old_title, new_title, old_salary, new_salary)
```

Cette table n'a pour but que de donner un exemple plus concret de l'utilisation des qualificatifs, elle est donc vide.

On crée un trigger qui, pour tout ordre LMD sur la table `EMP` insérera une ligne d'audit (de logging) en enregistrant l'ancienne et la nouvelle valeur du nom, du titre et du salaire.

```SQL
CREATE OR REPLACE TRIGGER audit_emp_values
AFTER INSERT OR UPDATE OR DELETE ON emp
FOR EACH ROW
BEGIN
	INSERT INTO audit_emp_table(user_name, timestamp, old_last_name, new_last_name, old_title, new_title, old_salary, new_salary)
	VALUES (USER, SYSDATE, :old.empno, :new.empno, :old.job, :new.job, :old.salary, :new.salary);
END;
/
```

Dans un trigger `ROW`, il est possible de faire référence aux valeurs d'une colonne avant et après le changement dû à un ordre LMD en préfixant le nom de celle-ci du qualificatif `OLD` ou `NEW`.

Selon l'opération de LMD effectuée, les valeurs `OLD` et `NEW` ne seront pas les mêmes : 

| Opération | Valeurs de `OLD`           | Valeur de `NEW`     |
| --------- | -------------------------- | ------------------- |
| INSERT    | `NULL`                       | Valeur insérée      |
| UPDATE    | Valeur avant la MàJ        | Valeur après la MàJ |
| DELETE    | Valeur avant la suppresion | `NULL`                |

Grâce à la condition `WHEN` il est possible de restreindre l'action du trigger aux lignes conformes à certaines conditions.

**Exemple : Calculer la nouvelle commission d'un vendeur quand une ligne est ajoutée ou modifiée dans la table `emp` :**

```SQL
CREATE OR REPLACE TRIGGER trigger_salaire_vendeur
BEFORE INSERT OR UPDATE OF salary ON emp
FOR EACH ROW
WHEN(new.job = 'VENDEUR')
BEGIN
	IF INSERTING THEN
		:new.comm := 0;
	ELSIF :old.comm IS NULL THEN
		:new.comm := 0;
	ELSE
		:new.comm := :old.comm * (:new.salary / :old.salary);
	END IF;
END;
/
```

