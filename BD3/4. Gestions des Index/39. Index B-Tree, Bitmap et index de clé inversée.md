### Index B-Tree

Le processus d'E/S (entrée/sortie) disque est le principal facteur déterminant la vitesse d'accès à une table. Pour réduire le temps d'E/S disque et améliorer les performances liées aux accès aux tables, Oracle permet de créer des **index de table**

L'index **B-Tree** est le type d'index le plus courant, et celui utilisé par défaut.

L'index **B-Tree** stocke la valeur de clé et le `ROWID` de chaque ligne de la table. La structure d'un index B-Tree comprends trois types de niveaux : 

- La racine
- Les blocs de branches
- Les nœuds de feuille

*B-Tree ne veut pas dire Binary tree, mais Balanced tree. Avant que vous vous le demandiez :D*

Au sommet d'un index B-Tree se trouve la **racine**. Elle contient les entrées qui pointent vers le niveau suivant dans l'index.

Les **blocs de branche** constituent le niveau suivant d'un index B-Tree. Ces blocs pointent vers les blocs du niveau suivant dans l'index.

<center><img src="https://2.bp.blogspot.com/-YdDUswXJy2g/VQEmhBSYUUI/AAAAAAAAM9Y/6j4MvwDDVsY/s1600/btree.gif">
</center>

Les nœuds de feuille constituent le niveau le plus bas d'un index B-Tree. Ces noeuds contiennent les entrées d'index qui pointent vers les lignes d'une table. 

Les blocs feuille sont doublement liés pour que vous puissiez facilement parcourir l'index dans l'ordre croissant ou décroissant des valeurs de clé.

Une entrée d'index B-Tree comporte les trois composants suivants : 

- Entête de l'entrée : Stocke le nombre de colonnes et les informations de verrouillage

- Couples (longueurs de colonne/valeur de clé) : Définit la taille d'une colonne dans une clé suivie de la valeur de la colonne

- `ROWID` : Indique l'index de ligne de la ligne contenant les valeurs de clé.

Un index B-Tree a plusieurs caractéristiques :

- Il contient une entrée pour chaque ligne de la table, mais il ne contient pas d'entrée pour une ligne affichant une valeur `NULL` dans toutes les colonnes clés d'index.

- Si plusieurs lignes contiennent la même valeur de clé, ces valeurs de clé sont répétées

- Dans un index non partititoné, toutes les lignes appartiennent au même segment. Par conséquent, un `ROWID` réduit est utilisé pour pointer vers les lignes de la table.

### Index à clé inversé 

Lors de l'insertion d'enregistrements par ordre croissant de valeur de clé, par exemple par numéro d'employé généré par le système, des goulots d'étranglements (bottleneck) d'E/S peuvent se produire dans l'index.

En effet, toutes les mises à jour d'index ont lieu au même endroit dans l'arborescence de l'index. Pour éviter ces goulots d'étranglement, Oracle propose l'index à clé inversé :

<center><img src="https://player.slideplayer.com/88/15636492/slides/slide_5.jpg"></center>
*Ici on voit que l'index contient les `empno` mais aussi le bloc de fichier, le numéro de ligne et le numéro de fichier référencé pour trouver rapidement la correspondance dans le système de fichier*

### Index bitmap

Un index **bitmap** est organisé comme un index B-Tree. Toutefois, le nœud de feuille stocke une bitmap pour chaque valeur de clé.

<center>
<img src="http://www.dba-oracle.com/images/bitmap_index_merge.jpg"></center>

Chaque bit de la bitmap correspond à un `ROWID` possible. En outre, si un bit est défini, cela signifie que la ligne comportant le `ROWID` correspondant contient également la valeur de la clé.

Un index bitmap peut être utilisé dans les situations suivantes : 

- Lorsqu'une table contient des millions de lignes et que la colonne clé à une [cardinalité](https://www.ibm.com/docs/fr/mam/7.6.0?topic=overview-relationship-cardinality) faible
- Lorsque les requêtes utilisent souvent une combinaison de la condition `WHERE` multiple avec l'opérateur `OR`.
- Lorsque les colonnes clé sont en lecture seule ou ne sont pas fréquemment mises à jour.

### Index bitmap ou Index B-Tree ?

Oracle offre la possibilité d'utiliser un index B-Tree ou un index bitmap. Pour déterminer l'index approprié en fonction des cas, il est indispensable de connaître les différences entre ces deux types d'index.

##### B-Tree

- Convient pour les colonnes de cardinalité élevée
- Les mises à jour sur les colonnes clé sont relativement légères
- Ne convient pas aux requêtes qui utilisent l'opérateur `OR`
- Utile dans un environnement [OLTP](https://www.oracle.com/fr/database/oltp-definition/) 

##### Bitmap

- Convient pour les colonnes à faible cardinalité
- Les mises à jour sur les colonnes clé sont très lourdes
- Convient aux requêtes qui utilisent l'opérateur `OR`
- Utile dans un environnement [DSS](https://en.wikipedia.org/wiki/Decision_support_system)

### Création d'un index B-Tree

L'index B-Tree est le type d'index le plus courant, et celui utilisé par défaut pour une table. Un index B-Tree stocke les couples (`ROWID` / Valeur de clé)

Ce type d'index peut être créé dans le compte de l'utilisateur auquel la table appartient ou dans un autre compte.

**Syntaxe SQL :**

```SQL
CREATE [UNIQUE] INDEX <[schema.]index_name> 
ON [schema.]table<(column [ASC|DESC],(column [ASC|DESC],...)>
[TABLESPACE <tablespace_name>]
[PCTFREE <integer>]
[INITRANS <integer>]
[MAXTRANS <integer>]
[STORAGE <clause>]
[LOGGING | NOLOGGING]
[NOSORT];
```

**Exemple :**

Créer un index B-Tree normal `emp_ind1` appartenant au schéma `SCOTT` :
- Cet index doit être créé pour la table `emp` dans le Tablespace `index01` avec la valeur du paramètre `PCTFREE` à 25. 
- Créer l'index à partir de la colonne `empno`

```SQL
CREATE INDEX SCOTT.emp_ind1 
ON SCOTT.emp(EMPNO) 
PCTFREE 25 
TABLESPACE INDEX01;
```

```
Index created.
```

### Création d'un index à clé inversé

Pour éviter les goulots d'étranglements d'E/S, Oracle propose l'index à clé inversé. 
Un index à clé inversé inverse les octets de chaque colonne indexée.

**Syntaxe :**

```SQL
CREATE [UNIQUE] INDEX <[schema.]index_name> 
ON [schema.]table<(column [ASC|DESC],(column [ASC|DESC],...)>
[TABLESPACE <tablespace_name>]
[PCTFREE <integer>]
[INITRANS <integer>]
[MAXTRANS <integer>]
[STORAGE <clause>]
[LOGGING | NOLOGGING]
REVERSE;
```

**Exemple :**

Créer un index à clé inversé `CUST_IND1` appartenant au schéma `SCOTT` :

- Créé pour la table `CUSTOMER`.
- L'index est stocké dans le Tablespace `INDEX02`
- L'index est créé à partir de la colonne `CUST_NO`
- La valeur du `PCTFREE` de l'index est de 30.

```SQL
CREATE UNIQUE INDEX SCOTT.cust_ind1
ON SCOTT.customer(cust_no) REVERSE
PCTFREE 30
TABLESPACE index02;
```

```
Index created.
```

### Création d'un index bitmap

Si les données impliquées ont une faible cardinalité, un index bitmap est plus approprié.

**Syntaxe SQL :**

```SQL
CREATE BITMAP INDEX <[schema.]index_name> 
ON [schema.]table<(column [ASC|DESC],(column [ASC|DESC],...)>
[TABLESPACE <tablespace_name>]
[PCTFREE <integer>]
[INITRANS <integer>]
[MAXTRANS <integer>]
[STORAGE <clause>]
[LOGGING | NOLOGGING]
[NOSORT];
```

>[!attention] Un index bitmap ne peut pas être unique.

**Exemple :**

Créer un index bitmap `ORD_IND1` pour la table `S_ORD` sur la colonne `inv_no`, stocké dans le Tablespace `INDEX01`. La valeur du paramètre `PCTFREE` est de 25.

```SQL
CREATE BITMAP INDEX SCOTT.ord_ind1
ON SCOTT.s_ord(inv_no)
PCTFREE 25
TABLESPACE index01;
```

```
Index created.
```

**Cours à voir :**
- [[40. Gestion des index (modification, reconstruction et suppression)]]