Le stockage de l'index d'une clé primaire ou unique peut être spécifié lors de la définition de la contrainte grâce à l'option `USING INDEX` de la clause `CONSTRAINT`.

Syntaxe SQL : 

```SQL
CONSTRAINT <nom_contrainte> {PRIMARY KEY | UNIQUE} 
(<liste_colonnes>) USING INDEX 
[specification_stockage | nom_index | (ordre_création_index) ]
```

- `specification_stockage` : 

```SQL
[ TABLESPACE <nom_tablespace> ]
[ PCTFREE <valeur> ]
[ <clause_stockage> ]
[ ONLINE ]
[ NOCOMPRESS | COMPRESS [n] ]
[ LOGGING | NOLOGGING ]
```

- `nom_index` : le nom d'un index qui existe déjà
- `ordre_creation_index` : ordre SQL de création d'index tel que vu [[35. Index - Vue d'ensemble|précédemment]].

**Exemple :** 

- Définition des clauses de stockage de l'index 

```SQL
ALTER TABLE adherent 
ADD CONSTRAINT adherent$pk PRIMARY KEY(numero) 
USING INDEX TABLESPACE indx PCTFREE 0 STORAGE (INITIAL 2M);
```

- Spécification d'un index déjà existant 

```SQL
ALTER TABLE adherent 
ADD CONSTRAINT adherent$uk01 UNIQUE(nom, prenom, telephone)
USING INDEX (
	CREATE INDEX adherent$ix01
	ON adherent(nom, prenom, telephone)
	TABLESPACE indx
	PCTFREE 25
	STORAGE (INITIAL 10M)
);
```

Par défaut, lorsqu'une contrainte de clé primaire ou de clé unique est créée ou activée. Oracle regarde s'il existe un index utilisable pour vérifier la contrainte. 

Cet index peut être unique ou non-unique mais doit posséder une clé égale à ou commençant par la clé de la contrainte. Si un tel index n'existe pas, Oracle crée un index unique pour vérifier la contrainte.

Dans ce cas, l'option `USING INDEX` de la clause `CONSTRAINT` permet de spécifier les caractéristiques de stockage de cet index.

Dans Oracle 12G, la clause `USING INDEX` peut : 

- mentionner explicitement le nom d'un index à utiliser pour vérifier la contrainte
- inclure un ordre SQL `CREATE INDEX` pour créer explicitement l'index associé à la contrainte.

Dans les deux cas, les autres options de la clause `USING INDEX` sont interdites.

L'index mentionné ou créé peut être unique ou non unique mais il doit être "compatible" avec la contrainte de clé primaire ou unique.

Si l'index est unique, la clé de l'index doit être égale à la clé de la contrainte.

Exemple :

```SQL
CREATE INDEX adherent$ix01 ON adherent(nom, prenom, telephone) TABLESPACE indx;
```

```SQL
ALTER TABLE adherent
ADD CONSTRAINT adherent$pk PRIMARY KEY(nom, prenom)
USING INDEX adhrent$ix01;
```

Fonctionnement, créer l'index avant la contrainte et le mentionner dans l'ordre de création de la contrainte équivaut strictement à créer l'index dans l'ordre de définition de la contrainte.

Utiliser une des deux clauses `USING INDEX` permet : 

- D'être plus explicite
- De désigner un index précis si plusieurs index peuvent être utilisés pour vérifier la contrainte.
- De créer un autre index que celui qui serait utilisé par défaut (avec une autre clé)
- Si aucun index n'existe déjà, généralement plus "longue" que la clé de la contrainte
- De créer explicitement un index non-unique (voir l'intérêt ci-après)

Par défaut, lorsqu'une clé primaire ou unique est supprimée :

- L'index associé est supprimé s'il est unique
- L'index associé est conservé s'il est non-unique

Depuis Oracle 9i, il est possible d'indiquer explicitement si l'index associé à une contrainte supprimée doit être conservé ou supprimé.

Syntaxe SQL : 

```SQL
ALTER TABLE DROP CONSTRAINT {<nom_contrainte> | PRIMARY KEY} {KEEP | DROP} INDEX;  
```

A priori, conserver un index unique lors de la suppression d'une contrainte de clé primaire ou unique n'a pas de sens : l'unicité est toujours vérifiée au niveau de l'index.

L'approche par défaut d'Oracle est relativement logique. Si une contrainte de clé primaire ou de clé unique est supprimée, c'est notamment que l'unicité n'est plus souhaitée : Supprimer l'index associé est donc logique. Par contre, un index non unique, ne vérifie pas l'unicité, peut donc être conservé, même lorsque la contrainte est supprimée.

**Cours à voir :**
- [[38. Classification des index]]