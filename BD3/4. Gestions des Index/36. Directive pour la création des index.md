
>[!danger] Important : Il est inutile d'indexer les petites tables

### Directives pour la création d'index simples

Les colonnes candidates à l'indexation sont les colonnes fréquemment présentes dans les clauses `WHERE`, comme critère de sélection ou de jointure.

En complément, il faut s'assurer que les requêtes correspondantes sont sélectives et ramènent moins de 5 à 10% des lignes de la table.

Cela implique donc que les valeurs de la colonne soient relativement uniques (beaucoup de valeurs distinctes), et que les conditions qui les utilisent soient elle-mêmes sélectives. Il ne faut donc pas indexer les colonnes ayant peu de valeurs distinctes (une colonne `genre={f,m}` par exemple)

Pour trouver les bonnes colonnes candidates à l'indexation, il faut analyser les requêtes `SELECT`, `UPDATE` et `DELETE`, et rechercher les colonnes les plus fréquemment utilisées dans les clauses `WHERE` (critère de sélection et jointure).

La performance d'un index dépend de sa sélectivité intrinsèque et de la sélectivité des requêtes qui l'utilisent. La sélectivité peut être définie comme le nombre moyen de lignes ramenées par une requête divisé par le nombre total de lignes.

Exemple : 

Prenons l'exemple de la table `ADHERENT` comprenant 100 000 personnes avec une répartition homogène homme/femme.

Considérons les clauses `WHERE` suivantes : 

| Clause `WHERE`                     | Sélectivité                     |
| ---------------------------------- | ------------------------------- |
| `WHERE numero = 12345`             | $\cfrac{1}{100 000} = 0.001 \%$ |
| `WHERE numero BETWEEN 1 AND 20000` | $\cfrac{20000}{100000} = 20 \%$ |
| `WHERE sexe = 'F'`                 | $\cfrac{50000}{100000} = 50\%$                                |

Ces exemples montrent que la colonne numéro est intrinsèquement sélective mais que certaines requêtes basées sur cette colonne peuvent ne pas l'être. Par contre la colonne `sexe` n'est pas intrinsèquement sélective.

Une colonne ayant peut de valeurs distinctes est intrinsèquement non-sélective.

Si une requête utilisant un index ramène plus de 10% des lignes, Oracle se révélera plus performant en réalisant un parcours complet de la table qu'en passant par l'index.

Cette règle des 5 à 10% n'est pas en soi une garantie de performance effective de l'index : de nombreux autres facteurs entrent en compte. C'est néanmoins un bon critère de départ, qu'il vaut valider en réalisant des tests.

Parmi les colonnes candidates, il faudra d'abord identifier les colonnes qui sont systématiquement présentes ensemble dans la clause `WHERE` : ce sont de bonnes candidates d'un **index composé** qui est généralement plus sélectif qu'un **index simple**.

### Directives pour la création des index

Si les colonnes `C1` et `C2` d'une table sont fréquemment utilisées ensemble dans les clauses `WHERE` et qu'il existe 10 valeurs distinctes pour `C1` (sélectivité de $10\%$) et qu'il y a la même situation pour `C2`, la sélectivité théorique du couple `(C1, C2)` est de $1\%$ (dans l'hypothèse où il n'y a pas de corrélation entre `C1` et `C2`)

Indexer les petites tables ne sert à rien car le nombre minimum d'entrées/sorties lors d'un accès par index est de 2. (1 entrée/sortie au minimum pour l'index et 1 entrée/sortie au minimum pour la table)

Or, grâce au paramètre `DB_FILE_MULTIBLOCK_READ_COUNT` (`DBFMRC` ci-après), Oracle peut lire `DBFMRC` blocs en une entrée/sortie lors d'un parcours complet de la table. Donc si la taille de la table est inférieure `DBFMRC` blocs, un index est moins performant que le parcours complet. Si la taille de la table est inférieure à $2 \times$`DBFMRC` blocs, un index est aussi performant (mais pas plus) que le parcours complet.

En général, indexer des tables comprenant quelques dizaines de blocs n'apporte rien.
Les valeurs `NULL` ne sont pas stockées dans les index : donc index une colonne pour améliorer les recherches `IS NULL` ne sert à rien.

Hormis les index uniques (définis par des clés), il n'est jamais certain qu'un index soit réellement performant : il faut donc le tester. 
Lors des tests d'index, il ne faut pas oublier de vérifier si les index ne dégradent pas trop les performances de mises à jour.

### Complément sur les index composés 

Un index composé est utilisé si les colonnes de tête de la clé d'index sont présentes dans la condition. L'ordre des colonnes est important dans un index composé.

Si un index composé existe sur les colonnes (`nom`, `prenom`) de la table `ADHERENT`, les trois requêtes suivantes utilisent l'index : 

```SQL
SELECT * FROM adherent WHERE nom = 'HEURTEL' AND prenom = 'Olivier';
```

```SQL
SELECT * FROM adherent WHERE prenom = 'Olivier' AND nom = 'HEURTEL';
```

```SQL
SELECT * FROM adherent WHERE nom = 'HEURTEL';
```

Par contre la requête suivante n'utilise pas l'index : 

```SQL
SELECT * FROM adherent WHERE prenom = 'Olivier';
```

L'ordre des colonnes n'a pas d'importance dans la clause `WHERE`.

Dans certains cas, si la première colonne de l'index à très peu de valeurs distinctes, Oracle est susceptible de subdiviser l'index en sous-index (un pour chaque valeur de la première colonne) et de parcourir chaque sous-index.

Dans certaines situations, il peut être intéressant d’ajouter dans la clé d'index des colonnes présentes dans la clause `SELECT`, pour éviter d'accéder à la table.

Pour la requête suivante : 

```SQL
SELECT numero_telephone FROM adherent 
WHERE nom = 'HEURTEL' AND prenom = 'Olivier';
```

Ajouter la colonne `NUMERO_TELEPHONE` dans l'index composé qui existe sur les colonnes (`NOM`,`PRENOM`) permet d'éviter l'accès à la table.

### Cas ou l'index est non utilisé

Exemples de clauses `WHERE` où l'index présent sur la colonne `nom` est non utilisé : 

| Exemple de clause `WHERE`                            | Justification                                                                                                                             |
| ---------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| `nom IS NULL`                                        | Les valeurs `NULL` ne sont pas dans l'index                                                                                               |
| `nom NOT IN('DUPONT', 'DUPOND')`, `nom <> 'HEURTEL'` | Les recherches "différent de" n'utilisent pas l'index                                                                                     |
| `nom LIKE '%TEL'`                                    | Les recherches `LIKE` n'utilisent pas l'index si le début de la chaîne n'est pas connu (recherches du type "contient", "se termine par"). |
| `SUBSTR(nom, 1, 1) = 'H'`                            | Généralement, lorsqu'une fonction est appliquée à la colonne, ou que la colonne est utilisée dans une expression                          |                                                     |                                                                                                                                           |

Exemples de clauses `WHERE` où l'index présent sur la colonne `nom` est utilisé :

| Exemple de clause `WHERE` | Justification                                                              |
| ------------------------- | -------------------------------------------------------------------------- |
| `nom > 'HEURTEL'`         | Les recherches de type "inférieur", "supérieur", "entre" utilisent l'index |
| `nom LIKE 'H%'`           | Le début de la chaîne de caractère est connue                                                                           |

Ce n'est pas parce qu'une requête n'empêche pas l'utilisation d'un index, que l'index est réellement utilisé. 

C'est l'optimiseur d'Oracle qui décidera d'utiliser ou non un index, en fonction des caractéristiques de la requête, de la table et des index. (*Un sujet trop vaste pour être abordé ici*)

**Cours à voir :**
- [[37. Index d'une contrainte de clé primaire ou unique]]
