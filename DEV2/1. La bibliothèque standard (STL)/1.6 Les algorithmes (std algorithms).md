La libraire standard de C++ inclut des algorithmes dits "standards", tels que la recherche d'√©l√©ments dans un conteneur, de l'√©l√©ment maximum, minimum ou autre d'un conteneur indiqu√©.

La partie "algorithmes" de la librarie standard s'inclut dans votre code √† l'aide de l'instruction suivante : 

```cpp
#include <algorithm>
```

Une fois ceci fait, vous aurez acc√®s √† une pl√©thore de nouvelles fonctions avec l'appel `std::fonction` qui vous permettront de ne pas avoir √† d√©velopper vous m√™me des algorithmes connus et "basiques". En plus d'√™tre d√©j√† √©crites, ces fonctions sont optimis√©es au plus possibles et ce depuis le d√©but de C++. Personne ne souhaite recoder tous les quatres matins la fonction max d'un vector en changeant √† chaque fois la condition de comparaison. 

## De quoi a besoin la section `<algorithm>` ?

Les algorithmes fournis par cette partie de la libraire standard n'a pas directement acc√®s √† vos variables (ce serait trop simple üòâ). C'est pourquoi vous allez devoir fournir plusieurs √©l√©ments importants aux fonctions de cette librairie. 

Vous aurez la plupart du temps besoin de fournir des [[1.5 Les it√©rateurs (std iterators)|it√©rateurs]] qui permettront aux fonctions de std::algorithm d'int√©ragir avec le contenu, et vous aurez aussi souvent besoin d'ajouter une fonction qui permettra d'effectuer ces op√©rations de grande ampleur.

## Fonctions principales

Vous pouvez observer la liste de toutes les fonctions disponibles dans std::algorithm [ici](https://cplusplus.com/reference/algorithm/).
Cependant quelques fonctions notables sont √† retenir : 

>[!question] std::find
> Syntaxe : `std::find(Iterator begin, Iterator end, T& val);`
> Permet de d√©placer un it√©rateur √† l'emplacement correspondant √† la valeur indiqu√©e. D√©r√©f√©rencer l'it√©rateur permettra d'acc√©der √† cette valeur.

>[!question] std::count
> Syntaxe : `std::count(Iterator begin, Iterator end, T& val);`
> Permet de compter le nombre d'apparition de la valeur entre les positions `begin` et `end`.
> Renvoie le nombre d'occurences de val dans le conteneur 

>[!question] std::swap
> Syntaxe : `std::find(T& a, T& b);`
> Permet d'√©changer les valeurs aux adresses `a` et `b`.

>[!question] std::transform
> Syntaxe : `std::transform(Iterator input_begin, Iterator input_end, Iterator output_begin, Fct function);`
> Permet de r√©cup√©rer toutes les valeurs partant de `input_begin` √† `input_end`, va les passer dans la fonction `function` (peut √™tre un simple op√©rateur), et les placer dans l'ordre √† partir de `output_begin`.

>[!question] std::fill
> Syntaxe : `std::fill(Iterator begin, Iterator end, T& val);`
> Permet de placer la valeur `val` depuis l'it√©rateur `begin` (inclu) jusqu'√† l'it√©rateur `end` (exclu).

>[!question] std::shuffle
> Syntaxe : `std::shuffle(Iterator begin, Iterator end, RandomEngine reng);`
> Permet de m√©langer l'emplacement des valeurs entre `begin` et `end` en suivant la g√©n√©ration al√©atoire du g√©n√©rateur `reng` (doit √™tre par exemple un `std::default_random_engine()`)

