
### Introduction

##### Qu'est ce qu'un processus : 

Lorsqu'on entre une commande dans un terminal, le shell va lancer un processus pour exécuter le programme. Pour faire court un processus c'est une instance active d'un programme, munie d'un jeu de données particulier (des paramètres, l'environnement, etc...) qui s'exécute. 

Le Shell va alors attendre la fin du processus et attendre la commande suivante.

##### Arborescence de processus

- Un processus dispose d'un numéro permettant son **identification**, il s'agit du **PID**

- Chaque processus à un père, sauf le processus de PID 1 qui correspond au système d'exploitation (`systemd` pour system-deamon qui correspond à l'appellation des processus par Linux, lancé avec la commande `/sbin/init splash`).

- Le numéro du processus père est appelé le **PPID** (Parent-PID)

- Un **processus père peut avoir plusieurs processus fils**.

---
### Dupliquer un processus actif : `fork`

La fonction `fork` possède le prototype suivant : 

```c
__pid_t fork (void)
```

On remarque que cette fonction ne prend pas de paramètre (on sait que le processus à dupliquer est le processus actuel, a copier de façon identique), mais elle renvoie une valeur de type `__pid_t` qui correspond au type des **PID**, qui peut être converti en `int` sans problème.

L'appel système `fork()` est le seul moyen de créer un processus en restant avec des instructions bas niveau. Elle demande un kernel de copier le processus en cours de façon exacte dans la RAM, et de poursuivre l'exécution de ces deux processus. Le nouveau processus est considéré comme un processus fils.

L'exécution continue dans les deux processus, à l'instruction qui suit le fork. Le PID, le PPID ainsi que la valeur de retour de l'instruction fork(), sont les trois seules informations qui diffèrent entre les deux processus : 

La valeur retournée par `fork()`:
- Dans le processus **père**, elle correspond au **PID** du fils
- Dans le processus **fils**, elle vaut 0.
- Si le `fork` échoue (très rarement mais cela doit être pris en compte), la valeur de retour vaut -1 et seul le père existe alors.

---

##### La manière la plus courante d'utiliser `fork` 

```c
int main(int argc, char** argv){
	
	// Du code (tant que c'est pas du spaghetti code ça va)
	
	pid_t fork_value = fork();
	if(fork_value != 0 ) {
		if(fork_value < 0){
			// Gestion des erreurs
		} else {
			// Code du processus père
		} 
	} else {
		// Code du processus fils
	}
	 
	// Du code aussi, et tjrs pas de spaghetti code pour vous 
	
}
```
### Récupération des PID : `getpid`, `getppid`, `getpgrp`, `getpgrp2`

- `getpid` renvoie le PID du processus actuel
- `getppid` renvoie le PPID du processus actuel (le PID du processus père)
- `getpgrp` renvoie le PID du groupe du processus courant
- `getpgrp2` renvoie le PID du groupe du processus dont on indique le PID.

>[!example] Exercice : Ecrire un programme en C qui créé deux fils. Tous les processus (le père et les fils) devront indiquer chacun leurs numéros de processus, le numéro de leur père et la valeur renvoyée par la primitive de création de processus. 
>
>Exécuter le programme plusieurs fois. Les valeurs affichées et l'ordre d'affichage sont-ils toujours les mêmes ?
> 
> Modifier le programme C précédent afin que le père attende la fin d’exécution de ces
deux fils avant de se terminer. Il affichera un message d’adieu juste avant de se terminer.
>
> ```c
>int first_fork = fork();  
>if(first_fork){  
>	// code parent  
>	int second_fork = fork();  
>	if(second_fork){  
>		// code parent  
>		wait(0);  
>		wait(0);  
>		printf("Je suis le processus père, mon PID est %i, et le fork n°1 m'a renvoyé %i, et le deuxième %i\n", getpid(), first_fork, second_fork);  
>	} else {  
>		 // code enfant 2  
>		printf("Je suis le processus enfant n°2, mon PID est %i, et mon PPID est %i, mon fork m'a renvoyé %i\n", getpid(), getppid(), second_fork);  
>	}  
>} else {  
>	// code enfant 1  
>	printf("Je suis le processus enfant, mon PID est %i, et mon PPID est %i, mon fork m'a renvoyé %i\n", getpid(), getppid(), first_fork);  
}
>```

---

### L'attente et la terminaison de processus `exit`, `wait` et `waitpid`

La fonction `exit` est plutôt simple à comprendre : 

```c
void exit(int __status)
```

Le statut passé en paramètre indique soit un arrêt normal avec la valeur 0 (peut être remplacé par la macro `EXIT_SUCCESS` pour une meilleure sémantique, ou par `EXIT_FAILURE` pour un code d'erreur par défaut), soit par un code d'erreur personnalisé en `int`.

---

La fonction `wait` dispose du prototype suivant :

```c
__pid_t wait (int *__stat_loc);
```

Elle permet à un processus père  d'attendre la fin d'un de ces processus fils (n'importe lequel), elle renvoie le PID du processus fils qui s'est terminé, ou elle renvoie `-1` si le processus n'a pas de fils ou qu'il s'est produit une erreur lors de l'attente.

Si un processus est déjà mort alors la fonction n'est pas bloquante et l'exécution se poursuit.
Toutes les ressources utilisées par le fils sont libérées.

Elle prend en paramètre un pointeur vers un `int` qui stockera l'état de fin du processus qui va s'arrêter. Si vous n'avez pas besoin de cette informations vous pouvez simplement appeler `wait(0)` ou `wait(NULL)`.

Si par contre vous avez donné un pointeur vers un `int` pour recevoir le code de retour vous pouvez le traiter ainsi :  

- La macro `WIFEXITED(status)` est non nulle si le fils s'est terminé normalement
- La macro `WEXITSTATUS` donne le code de retour du fils tel qu'il l'a mentionné lors de son appel de la fonction `exit()`, cette macro n'est valide que si `WIFEXITED(status) != 0`

Il existe aussi la fonction `waitpid` : 

```c
__pid_t waitpid (__pid_t __pid, int *__stat_loc, int __options);
```

La fonction `waitpid` prend en paramètre un PID, le pointeur vers l'`int` qui recevra le statut du processus, et des options :

- La valeur de `__pid` peut être : 
	- $< -1$ pour attendre n'importe quel processus fils appartenant au groupe d'ID `__pid`.
	- $-1$ (macro : `WAIT_ANY`) pour attendre n'importe quel processus fils 
	- $0$ (macro : `WAIT_MYPGRP`) pour attendre la fin de n'importe quel processus du même groupe que le processus appelant. (Dans le cas d'un fils qui attendrait l'arrêt d'un "frère")
	- $> 0$ pour attendre la fin du processus de PID `__pid`. 

- Il existe différentes options, la plus utile étant `WNOHANG` :
	- `WNOHANG` - Ne bloque pas le processus appelant
	- `WUNTRACED` - Renvoie le statut des enfants terminés dans `__stat_loc`
	- `WEXITED` - Attendre que des processus enfants aient terminé
	- `WSTOPPED` - Attendre que des processus enfants aient été stoppés par un signal système (`SIGSTOP`)
	- `WCONTINUED` - Attendre qu'un programme ayant été stoppé soit relancé (via le signal `SIGCONT` : continuer)


--- 

### La temporisation d'un processus (mettre en pause) : `sleep`

La fonction `sleep` possède le prototype suivant : 

```c
unsigned int sleep (unsigned int __seconds);
```

Elle se comporte comme la commande shell `sleep`, et prend en paramètre un `int` qui correspond au nombre de secondes à attendre, et retourne le nombre de seconds qui ont actuellement été attendues. (Car on peut réveiller un processus avec le signal `SIGALRM`).

La différence avec la fonction `wait` est que `wait` va bloquer le processus jusqu'à la fin d'un fils, soit le temps d'attente n'est pas déterminé, alors qu'avec `sleep` on peut spécifier combien de temps attendre.

>[!example] La temporisation VS l'attente
>
>Un exemple d'utilisation de `wait` et `sleep` : 
>```c
>int pid_fils = fork();
>if(pid_fils != 0){
>	printf("Je suis le père.\n");
>	wait(0);
>	printf("Mon fils a terminé.\n");
>} else {
>	printf("Je suis le fils.\n");
>	sleep(2);
>	printf("Arrêt du fils, j'ai attendu 2 secondes.\n")
>	exit(0);
>}
>```
>Qui donnera comme résultat d'exécution : 
>```
>Je suis le père.
>Je suis le fils.
>Arrêt du fils, j'ai attendu 2 secondes.
>Mon fils a terminé.
>```

>[!example] Exercice : Ecrire un programme en C qui créé deux fils. Tous les processus (le père et les fils) devront indiquer chacun leurs numéros de processus, le numéro de leur père et la valeur renvoyée par la primitive de création de processus. 
>
>Exécuter le programme plusieurs fois. Les valeurs affichées et l'ordre d'affichage sont-ils toujours les mêmes ?
> 
> Modifier le programme C précédent afin que le père attende la fin d’exécution de ces
deux fils avant de se terminer. Il affichera un message d’adieu juste avant de se terminer.
>
>Modifier le programme C précédent afin que chacun des fils attende 5 secondes avant
de se terminer. Chacun affichera un message avant et après l’attente.
>```c
>int first_fork = fork();  
>if(first_fork){  
>	// code parent  
>	int second_fork = fork();  
>	if(second_fork){  
>		// code parent  
>		int *stat_loc;  
>		wait(stat_loc);  
>		wait(stat_loc);  
>		printf("Je suis le processus père, mon PID est %i, et le fork n°1 m'a renvoyé %i, et le deuxième %i\n", getpid(), first_fork, second_fork);  
>	} else {  
>		 // code enfant 2  
>		printf("Début de l'attente de 5 secondes, enfant 2\n");  
>		sleep(5);  
>		printf("Fin de l'attente de 5 secondes, enfant 2\n");  
>		printf("Je suis le processus enfant n°2, mon PID est %i, et mon PPID est %i, mon fork m'a renvoyé %i\n", getpid(), getppid(), second_fork);  
>	}  
>} else {  
>	// code enfant 1  
>	printf("Début de l'attente de 5 secondes, enfant 1\n");  
>	sleep(5);  
>	printf("Fin de l'attente de 5 secondes, enfant 1\n");  
>	printf("Je suis le processus enfant, mon PID est %i, et mon PPID est %i, mon fork m'a renvoyé %i\n", getpid(), getppid(), first_fork);  
}
>```

---

# Communication entre les processus

### Faire communiquer des processus avec les tubes

Les tubes représentent un mécanisme de communication entre les processus.

La transmission de donnés entre processus s'effectue à travers un canal de communication : les données écrites à une extrémité sont lues à l'autre extrémité

Un tube anonyme permet la communication uniquement entre les processus ayant un ancêtre commun. Il est créé par un processus et la transmission des descripteurs associés ne se fait que vers ses descendants après un appel à `fork`.

### Communication  par tubes anonymes : `pipe`

La fonction `pipe` est définie ainsi : 

```c
int pipe (int __pipedes[2])
```

On observe que la fonction `pipe` prend en paramètre un tableau de 2 `int` et qu'elle renvoie un `int`:

- La valeur de retour de pipe correspond à `0` si le tube a pu être créé, sinon `-1` sera renvoyée.
- Le paramètre `int __pipedes[2]` correspond à l'adresse d'un tableau de deux entiers, tableau dans lequel seront placés les deux descripteurs de fichiers du tube anonyme.

>[!important] Fonctionnement de `int __pipedes[2]` 
>Dans le premier emplacement du tableau, soit `__pipedes[0]`, on retrouvera le descripteur de lecture du tube
>Dans le second emplacement du tableau, soit `__pipedes[1]`, on retrouvera le descripteur d'écriture du tube.

>[!example] Exercice : Utilisation de pipe() et wait() : modifier le processus de la question 1 de l’exercice 1 pour que le processus père puisse maintenant permettre à l'utilisateur de rentrer des nombres. Il transmet à l'aide d'un ou plusieurs tubes les nombres impairs au premier processus fils qu'il a créé et les nombres pairs au second (on transmettra au choix soit la représentation binaire de chaque entier, soit la suite de chiffres correspondante). 
>
>Quand l'utilisateur rentre la valeur 0, le père envoie également la valeur 0 à ses fils pour leur donner l'ordre de se terminer, puis, attend qu'ils soient terminés tous les deux avant de se terminer. Chaque processus laisse un message d'adieux avant sa terminaison.

```c
int pipe_pair[2], pipe_impair[2];  
  
// On prépare les pipes mémoire  
pipe(pipe_pair);  
pipe(pipe_impair);  
  
if(fork() != 0){  
    if(fork() != 0){  
  
        int i = -1;  
        char temp[100];  
        while (1){  
            memset(temp, '\0', 100);  
            scanf("%d", &i);  
            int nb_chars = sprintf(temp, "%d", i);  
            if(i == 0){  
                sleep(1);  
				  
                write(pipe_pair[1], "0", 1);  
				write(pipe_impair[1], "0", 1);  
				  
                close(pipe_pair[0]);  
                close(pipe_pair[1]);  
				  
                close(pipe_impair[0]);  
                close(pipe_impair[1]);  
				  
                int first_dead = (int)wait(0);  
                printf("Processus fils terminé : %i\n", first_dead);  
				  
                int second_dead = (int)wait(0);  
                printf("Processus fils terminé : %i\n", second_dead);  
				  
                printf("Adieux du père !\n");  
                exit(EXIT_SUCCESS);  
            } else {  
                write(((i % 2 == 0) ? pipe_pair[1] : pipe_impair[1]), temp, nb_chars);  
            }  
        }  
    } else {  
        while(1) {  
            // second child  
            char temp[100];  
            memset(temp, '\0', 100);  
            int chars_read = read(pipe_pair[0], temp, 100);  
            if(chars_read >= 0 && temp[0] == '0'){  
                printf("Adieux du second fils !\n");  
                printf("Dernière valeur traitée %s !\n", temp);  
                exit(EXIT_SUCCESS);  
            } else {  
                printf("Valeur reçue par le 2e fils : %s\n", temp);  
            }  
        }  
    }  
} else {  
    while(1) {  
        // first child  
        char temp[100];  
        memset(temp, '\0', 100);  
        int chars_read = read(pipe_impair[0], temp, 100);  
        if(chars_read >= 0 && temp[0] == '0'){  
            printf("Adieux du premier fils !\n");  
            printf("Dernière valeur traitée %s !\n", temp);  
            exit(EXIT_SUCCESS);  
        } else {  
            printf("Valeur reçue par le 1er fils : %s\n", temp);  
        }  
    }  
}
```


### Remplacer le processus courant par un programme/processus externe : `exec`, `execve`, `execlp`

Il existe plusieurs fonction pour réaliser cette tache : 

| Primitive | Prototype                                                  | Format d'argument | Passage d'environnement | PATH |
| ---------:| ---------------------------------------------------------- |:-----------------:|:-----------------------:|:----:|
|   `execl` | `int execl(char* path,char* arg0,char* arg1, …, NULL);`    |       Liste       |       Automatique       | Non  |
|   `execv` | `int execv(char* path,char* arg[]);`                       |      Tableau      |       Automatique       | Non  |
|  `execle` | `int execle(char* path,char* arg0,…, NULL, char* envp[]);` |       Liste       |         Manuel          | Non  |
|  `execve` | `int execve(char* path,char* arg[],char* envp[]);`         |      Tableau      |         Manuel          | Non  |
|  `execlp` | `int execlp(char* file,char* arg0,char* arg1, …, NULL);`   |       Liste       |       Automatique       | Oui  |
|  `execvp` | `int execvp(char* file,char* arg[]);`                      |      Tableau      |       Automatique       | Oui  |

La famille des fonctions `exec...` remplace l'image en mémoire du processus en cours par un nouveau processus

Toutes ces fonctions ont le même rôle mais ne disposent pas du même prototype.

En cas de succès, il n'y a pas de valeur de retour car le programme a changé, cependant le code d'erreur est `-1` si le changement n'a pas eu lieu.

Les différents noms des fonctions `exec...` sont faciles à retenir : 

- `l` : Passage des arguments via une liste
- `v`: Passage des arguments sous forme de tableau (vecteur)
- `p`: Recherche du fichier a exécuter avec la variable d'environnement PATH.
- `e` : Transmission d'un environnement en dernier paramètre, en remplacement de l'environnement courant.

>[!example] Exercice : Ecrire un programme en C qui propose à l'utilisateur le menu suivant jusqu'à ce que le choix "quitter" soit sélectionné :
>
>1/ ls
>2/ ps -ef
>3/ find . -name data -print
>4/ quitter
>
> ---
>
>```c
>printf("1/ ls\n2/ ps -ef\n3/ find . -name data -print\n4/ quitter\n");  
>int i;  
>scanf("%d", &i);  
>if(i != 4){  
>	execlp("./prg", NULL);  
>} else exit(EXIT_SUCCESS);
>```
### Lancement d'une commande : `system`

La fonction `system` est déclarée ainsi : 

```c
int system (const char *__command)
```

Cette fonction prend en paramètre une chaîne de caractère contenant une commande shell à exécuter. La valeur de retour correspond au code de retour de la commande, ou alors -1 en cas d'erreur (et 127 pour execve).

Cette fonction créée un nouveau processus `/bin/sh` qui exécute la commande indiquée : `/bin/sh -c <command>`
