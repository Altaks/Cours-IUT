Nous verrons le fonctionnement des méthodes concernant la gestion des fichiers en général.

### La fonction `open`

Elle permet d'ouvrir un fichier qui restera ouvert jusqu'à la fin du processus (donc il sera fermé par l'OS) ou alors lors de l'appel de la fonction `close`.

Elle est définie par deux prototypes :

```c
int open (const char *__file, int __oflag)
```

```c
int open (const char *__file, int __oflag, mode_t __mod)
```

On remarque qu'elle renvoie un `int` qui correspondra au **file descriptor** du fichier ouvert, ou `-1` si le fichier n'a pas pu être ouvert !

Elle prend en paramètre : 
- `char* __file` qui correspond au **chemin du fichier** a ouvrir
- `int __oflag` qui correspondra au **mode d'ouverture du fichier**, il en existe énormément mais les plus courants sont les suivants : 
	- `O_RDONLY` qui permet d'ouvrir le fichier en mode de **lecture** uniquement
	- `O_WRONLY` qui permet d'ouvrir le fichier en mode d'**écriture** uniquement
	- `O_RDWR` qui permet d'ouvrir le fichier en mode **lecture-écriture**.
	- `O_CREAT` qui permet de créer le fichier indiqué 
	- `O_APPEND` qui permet, en mode `O_WRONLY` ou `O_RDWR` d'ajouter du contenu a la fin du fichier
	- `O_TRUNC` qui permet, en mode `O_WRONLY` ou `O_RDWR` de détruire le contenu précédent et d'écrire au début du fichier
	- `O_EXCL` qui, combinée avec `O_CREAT` permet de créer le fichier s'il n'existe pas déjà.
	- [Autres](http://manpagesfr.free.fr/man/man2/open.2.html)
- `mode_t mod` qui correspond aux permissions à donner au fichier si on souhaite le créer lors de l'ouverture. La valeur devra être donnée en octale, donc précédée d'un 0. Si cette valeur est oubliée lors de l'ouverture, les droits appliqués au fichier seront aléatoires.

##### Quelques exemples d'appels d'`open`

```c
int fd = open("file.txt", O_RDONLY | O_CREAT | O_EXCL);
```
Pour créer un fichier `file.txt` dans le répertoire d’exécution uniquement s'il n'existe pas déjà et l'ouvrir en mode lecture uniquement. Si le fichier existe déjà, il ne sera pas ouvert. 

```c
int fd = open("file.txt", O_RDONLY);
```
Pour ouvrir un fichier `file.txt` dans le répertoire d’exécution en mode de lecture uniquement

```c
int fd = open("file.txt", O_CREAT | O_WRONLY | O_TRUNC, 0600);
```
Pour créer/écraser un fichier `file.txt`, l'ouvrir en mode écriture uniquement, supprimer le contenu déjà présent s'il y en a, et attribuer les droits `600` soit `rw-,---,---` au fichier.

>[!important] Déroulement d'un appel d'`open` vu par l'OS
>
> Trouver l'[inode](https://fr.wikipedia.org/wiki/N%C5%93ud_d%27index) du fichier (dans la table des inodes)
> - Charger l'inode en mémoire si elle n'y est pas
> 
> Vérifier les droits d'accès de l'utilisateur sur le fichier
> >[!attention] La vérification des droits ne se fait qu'à l'ouverture !
> >Si on change les droits d'accès au fichier durant l'execution du programme, ça ne bloque pas le processus qui utilise le fichier car il n'est pas au courant des changements !
>
> Allouer une entrée dans la table des fichiers ouverts
> 
> Positionner l'offset courant (le pointeur de lecture/écriture) (0 ou EOF (end of file) en cas d'ouverture en ajout)
> 
> Allouer une place dans la table des descripteurs de fichiers du processus
> 
> Renvoyer au processus appelant le descripteur obtenu 

---

### Rappel de la compilation d'un programme C/C++

Afin d'obtenir un programme lisible par la machine sans utiliser d'IDE particulier ou il suffit d'appuyer sur un simple bouton (bien que ça soit très agréable une fois configuré correctement), 
pour convertir ceci : 

```c
#include <stdio.h>  
#include <fcntl.h>  
  
int main() {  
    // On initialise le compteur à 3 : stdin, stdout et stderr étant déjà présents et ouverts par défaut par le programme  
    int count = 3;  
  
    // On compte le nombre d'ouvertures disponibles (on crée le fichier dans le répertoire d'éxecution)  
    while(open("file.txt", O_CREAT | O_RDONLY) != -1){  
        count++;  
    }  
  
    // On affiche le nombre d'ouvertures disponibles, résultat obtenu sur pc portable : 1 048 576 soit 2^20. Résultat obtenu sur les pc de l'IUT : 1024. Skill diff
    printf("Le nombre maximal de fichiers disponible a l'ouverture est de : %d", count);  
  
    return 0;  
}
```

en ceci : 

```asm
main:  
    endbr64                           
    push   %rbp                       
    mov    %rsp,%rbp                  
    sub    $0x10,%rsp                 
    movl   $0x3,-0x4(%rbp)            
    jmp    0x555555555182 <main+25>   
    addl   $0x1,-0x4(%rbp)            
    mov    $0x40,%esi                 
    lea    0xe7a(%rip),%rax        # 0x555555556008  
    mov    %rax,%rdi                  
    mov    $0x0,%eax                  
    call   0x555555555070 <open@plt>  
    cmp    $0xffffffff,%eax           
    jne    0x55555555517e <main+21>   
    mov    -0x4(%rbp),%eax            
    mov    %eax,%esi                  
    lea    0xe6c(%rip),%rax        # 0x555555556018  
    mov    %rax,%rdi                  
    mov    $0x0,%eax                  
    call   0x555555555060 <printf@plt>  
    mov    $0x0,%eax                  
    leave                             
    ret
```

il vous faudra exécuter la commande suivante (en ayant `gcc` installé sur votre ordinateur)

Sous Unix/Linux (`sudo apt install build-essential` sur Linux et c'est réglé)
```bash
gcc -o prg prg.c
```

Sous Windows (après installation d'une chaîne de compilation comme [MinGW](https://dev.to/gamegods3/how-to-install-gcc-in-windows-10-the-easier-way-422j))
```bash
gcc -o prg.exe prg.c
```

Et vous aurez votre programme fraîchement compilé !
Vous n'aurez plus qu'à faire `./prg` ou `./prg.exe` et voilà, le tour est joué !

>[!example] Exercice 1 : Ecrire un programme qui ouvre des fichiers sans jamais les fermer. Combien de fichiers votre ordinateur peut-il ouvrir ? 

```c
#include <stdio.h>  
#include <fcntl.h>  
  
int main() {  
    // On initialise le compteur à 3 : stdin, stdout et stderr 
    // étant déjà présents et ouverts par défaut par le programme  
    int count = 3;  
    
    // On compte le nombre d'ouvertures disponibles 
    // (on crée le fichier dans le répertoire d'éxecution)  
    while(open("file.txt", O_CREAT | O_RDONLY) != -1){  
        count++;  
    }  
    
    // On affiche le nombre d'ouvertures disponibles, 
    // Résultat obtenu sur pc portable : 1 048 576 soit 2^20. 
    // Résultat obtenu sur les pc de l'IUT : 1024. Jungle diff
    printf("Le nombre maximal de fichiers disponible a l'ouverture est de : %d", count);  
    
    return 0;  
}
```

---

### Fermer un fichier déjà ouvert : `close`

Afin de fermer un fichier déjà ouvert par votre processus, il existe une fonction :

```c
int close(int __fd);
```

Avec `int __fd` qui correspond donc au **file descriptor** du fichier a décharger et la méthode renvoie un `int`, qui vaudra 0 si l'**inode** est complètement déchargée.

Lors de la fermeture du fichier, les ressources associées à celle-ci sont libérées.


---

### Lire à partir d'un fichier ouvert : `read`

La fonction `read` permet de lire un certain nombre d'octets sur un fichier ouvert.

```c
ssize_t read (int __fd, void *__buf, size_t __nbytes);
```

Qui renvoie un type `ssize_t` qui correspond au nombre d'octets qui ont été lus avec succès, peut être cast en `int`.

Elle prend en arguments : 
- `int __fd` le **file descriptor** du fichier ouvert
- `void* __buf` l'adresse d'un **buffer** créé au préalable par l'utilisateur.
- `size_t __nbytes` le **nombre d'octets** que le kernel doit lire au maximum.

La fonction peut retourner moins que les `__nbytes` demandés en cas :
- D'arrivée à la fin du fichier
- De lecture sur un tube ou un terminal
- D'interruption par un signal (SIGABRT, SIGSTOP, SIGKILL, etc...)

La méthode vérifie la validité du descripteur de fichiers et du bon mode d'ouverture

>[!attention] Les droits d'accès de l'utilisateurs ne sont pas testés

---

### Ecrire dans un fichier ouvert : `write`

```c
ssize_t write (int __fd, const void *__buf, size_t __n);
```

Qui renvoie un type `ssize_t` qui correspond au nombre d'octets qui ont été écrits avec succès. 

Elle prend en arguments : 
- `int __fd` le **file descriptor** du fichier sur lequel écrire
- `const void* __buf` l'adresse d'un **buffer** immuable qui doit contenir le contenu à écrire
- `size_t __n` qui correspond au **nombre d'octets à écrire** sur l'instant depuis le buffer.

Dans un fichier, la modification de la position et l'écriture se font de manière atomique (en même temps).

---

### Quelques informations supplémentaires #QoL

Dans la librairie `unistd.h` qui contient les déclarations des méthodes `open, read, write, ...`  il existe 3 macros intéressantes : 

- `STDIN_FILENO` qui correspond au file descriptor de l'**entrée standard** (quand vous écrivez dans le terminal de votre programme)
- `STDOUT_FILENO` qui correspond au file descriptor de la **sortie standard** (quand vous voulez afficher quelque chose dans la console)
- `STDERR_FILENO` quand vous voulez écrire une erreur dans la sortie d'**erreur standard**.

> [!example] Exercice 2 : Utiliser l’appel système open() pour ouvrir un fichier qui sera spécifié sur la ligne de commande. Lire les 10 premiers octets du fichier avec l’appel système read(), puis les afficher sur la sortie standard en utilisant write(). 

```c
// On vérifie le bon nombre d'arguments
if(argc < 2) {  
    printf("Vous n'avez pas indiqué de fichier a ouvrir : \n./prg <file_path>");  
}  
// On ouvre le fichier en mode lecture uniquement et on s'assure qu'il s'est bien ouvert
char* filepath = argv[1];  
int df = open(filepath, O_RDONLY);  
if(df == -1) {  
    printf("Le fichier indiqué est impossible a ouvrir : %S", argv[1]);  
}  

// On lit le fichier via un buffer, et on réécrit le contenu du buffer dans la console via la macro de sortie standard
char buffer[256];  
ssize_t read_len = read(df, buffer, 10);  
write(STDOUT_FILENO, buffer, read_len);  

// On oublie pas de fermer le fichier comme des grands
close(df);
```

> [!example] Exercice 3 : Réécrire un programme cp simple (copie d’un fichier vers un autre). Pour créer le fichier "cible", n’oubliez pas d’utiliser les flags O_CREAT, O_TRUNC, et le troisième paramètre de open(), pour positionner correctement les droits du fichier nouvellement créé

```c
// On vérifie le bon nombre d'arguments
if(argc < 3) {  
    printf("Vous n'avez pas indiqué les bons arguments: \n./prg <file_path> <destination>");  
}  

// On ouvre le fichier a copier
char* tocopy = argv[1];  
int tocopy_df = open(tocopy, O_RDONLY);  
if(tocopy_df == -1) {  
    printf("Le fichier indiqué est impossible a ouvrir : %S", argv[1]);  
}  

// On créé/écrase le fichier de destination
char* towrite = argv[2];  
int towrite_df = open(towrite, O_CREAT | O_WRONLY | O_TRUNC, 0600);  
if(towrite_df == -1){  
    printf("Le fichier n'a pas pu être créé, peut être que vous n'avez pas les permissions requises");  
}  

// On prépare un buffer de 1Kio
char buf[1024];  

// On copie le contenu du fichier vers la destination
int len = 1024;  
while(len == 1024){  
    len = read(tocopy_df, buf, 1024);  
    write(towrite_df, buf, len);  
}  

// On oublie pas de fermer les fichiers comme des grands
close(tocopy_df);  
close(towrite_df);
```

---

### Se positionner dans un fichier ouvert : `lseek`

Pour les curieux qui veulent comprendre pourquoi [`lseek` et non `seek` ](https://softwareengineering.stackexchange.com/questions/244525/why-is-the-function-called-lseek-not-seek)

```c
__off_t lseek (int __fd, __off_t __offset, int __whence);
```

Cette méthode renvoie un type `__off_t` qui correspond, en octets, à la nouvelle position dans le fichier.

Elle prend en paramètres : 
- `int __fd` le **file descriptor** du fichier sur lequel se déplacer
- `__off_t __offset` le **décalage à effectuer** (décalage vers vers la "droite", vers la fin du fichier).
- `int __whence` qui correspond au **point de départ** du décalage :
	- `SEEK_SET` définit le point de départ comme le début du fichier
	- `SEEK_CUR` définit le point de départ comme l'emplacement actuel dans le fichier (si vous avez fait des `read` ou des `write` auparavant)
	- `SEEK_END` définit le point de départ comme la fin du fichier

Le décalage peut se faire au delà de la fin du fichier, et dans ce cas l'appel de `read` provoquerait un changement de la taille réelle du fichier. L'espace situé entre la fin du fichier et l'emplacement d'appel du `read` sera alors rempli de `0` .

>[!example] Exercice 4 : Ecrire un programme qui se comporte comme la commande cat -n. Si aucun nom de fichier n'est donné le programme affiche les caractères venant de l'entrée standard à l'écran en ajoutant un numéro de ligne. Si des noms de fichiers sont spécifiés, le programme affiche le contenu du fichier en numérotant les lignes.

```c
int df;  
if(argc == 0){  
    // il n'y a pas de fichier spécifié, on ouvre la sortie standard  
    df = STDIN_FILENO;  
} else {  
    df = open(argv[1], O_RDONLY);  
    if(df == -1){  
        printf("Le fichier spécifié n'a pas pu être ouvert : %S", argv[1]);  
        exit(EXIT_FAILURE); // En cas de problème on ferme le programme avec le code d'erreur standard.  
    }  
}  

// On prépare le buffer, le compteur de lignes et on affiche le préfixe de la ligne 0.
char buff[1024];  
int len = 1024;  
int counter = 0;  
printf("0 ");  

// On parcourt le fichier par bloc de 1024 octets
while(len == 1024){  
    len = read(df, buff, 1024);  
	
	// Pour chaque caractère du bloc lu, s'il s'agit d'un saut de ligne on l'affiche avec un numéro, sinon on affiche le caractère.
    for(int buff_index = 0; buff_index < len; buff_index++){  
        if(buff[buff_index] == '\n'){  
            counter++;  
            printf("\n%d ", counter);  
        } else {  
            printf("%c", buff[buff_index]);  
        }  
    }  
}

// On oublie pas de fermer le fichier comme des grands
close(df);
```

> [!example] Exercice 5 : Ecrire un programme qui ouvre un fichier ./res.data en lecture et qui lit 10 caractères à partir du 30ème caractère, puis les affichent sur la sortie standard (c’est à dire l’écran

```c
// On ouvre un fichier res.data
char* path = "/home/altaks/Téléchargements/res.data";  
int df = open(path, O_RDONLY);  
if(df == -1) {  
    printf("Le fichier n'a pas pu être ouvert.");  
}  

// On se déplace de 30 caractères par rapport au début du fichier.
int offset = lseek(df, 30, SEEK_SET);  
if(offset == -1) {  
    // une erreur est survenue.  
    printf("Le décalage ne s'est pas passé comme prévu.");  
}  

// On récupère 10 caractères qu'on écrit dans la sortie standard.
char buffer[10];  
int len = read(df, buffer, 10);  
write(STDOUT_FILENO, buffer, len);

// On oublie pas de fermer le fichier comme des grands
close(df);
```

